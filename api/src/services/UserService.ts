import Logger from '../Logger';
import * as UserDao from '../database/dao/UserDao';
import * as UserProfileDao from '../database/dao/UserProfileDao';
import * as PermissionDao from '../database/dao/PermissionDao';
import * as UserProfileRoleDao from '../database/dao/UserProfileRoleDao';
import * as TenantService from './TenantService';
import UserProfile from '../database/models/UserProfile';
import Permission from '../database/models/Permission';
import { sequelize } from '../config/database';
import DuplicatedUserError from '../errors/DuplicatedUserError';
import UserNotFoundError from '../errors/UserNotFoundError';
import ExceededLicenseUsageError from '../errors/ExceededLicenseUsageError';
import { generateRandomPassword } from './PasswordService';
import * as EmailService from './EmailService';
import { UserDetailsResponseModel, ActiveUserResponseModel } from '../typings/ResponseFormats';
import { hashPassword } from './PasswordService';

const LOG = new Logger('UserService.ts');

/**
 * Search user with query and optional pagination
 *
 * @param s offset for pagination search
 * @param l limit for pagination search
 * @param q query for searching
 *
 * @returns the total counts and the data for current page
 */
export const searchUsersWithPagination = async (offset: number, limit?: number, q?: string, role?: string) => {
  LOG.debug('Searching Users with Pagination');

  const { rows, count } = await UserProfileDao.getPaginated(offset, limit, q, role);

  return { rows, count };
};

/**
 * Get UserProfile based on userId
 * @param userId the id of the desired UserProfile
 *
 * @returns the user profile
 */
export const getUserProfile = async (userId: number): Promise<UserProfile> => {
  LOG.debug('Getting User Profile from userId');

  const userProfile = await UserProfileDao.getById(userId);

  return userProfile;
};

/**
 * Get all distinct permission of the user
 *
 * @param userId the id of the desired user
 *
 * @returns a array of distinct permission
 */
export const getUserPermissions = async (userId: number): Promise<Permission[]> => {
  LOG.debug('Getting User Permissions from userId');

  const permissions = (await PermissionDao.getDistinctPermissionsByUserId(userId)) as Permission[];

  return permissions;
};

export const getUserFullDetailsById = async (userId: number): Promise<UserDetailsResponseModel> => {
  LOG.debug('Getting User full details from userId');

  const user = await UserProfileDao.getUserFullDetails(userId);

  return user;
};

/**
 * Check if a user with the same loginName exists
 * Create a new user in the system, based on current user tenancy
 *
 * @param displayName of the new user
 * @param email of the new user
 * @param contactNumber of the new user
 * @param password of the new user
 * @param roleId of the new user
 * @param tenant of the user
 *
 * @returns UserDetailsModel
 */
export const createUser = async (displayName: string, email: string, contactNumber: string, roleId: number, tenant: string) => {
  LOG.debug('Creating User');

  if (await isUserExistsByLoginName(email)) {
    throw new DuplicatedUserError();
  }

  if (!(await TenantService.validateLicenseLimit(tenant))) {
    throw new ExceededLicenseUsageError();
  }

  const transaction = await sequelize.transaction();

  try {
    const autoGeneratedPassword = generateRandomPassword();
    const user = await UserDao.createUser(email, autoGeneratedPassword, tenant, transaction);
    const userProfile = await UserProfileDao.createUserProfile(user, displayName, contactNumber, transaction);
    await UserProfileRoleDao.create(userProfile.get('id'), roleId, transaction);
    await EmailService.sendNewUserWelcomeEmail(userProfile.email, userProfile.displayName, autoGeneratedPassword, userProfile.email);

    await transaction.commit();

    return await getUserFullDetailsById(user.id);
  } catch (err) {
    await transaction.rollback();
    throw err;
  }
};

/**
 *
 * @param displayName to be updated
 * @param email to be updated
 * @param contactNumber to be updated
 * @param roleId to be updated
 *
 * @returns void
 */
export const editUser = async (
  userId: number,
  displayName?: string,
  email?: string,
  newPassword?: string,
  contactNumber?: string,
  roleId?: number
) => {
  LOG.debug('Editing User');

  const user = await UserDao.getById(userId);
  const userProfile = await UserProfileDao.getById(userId);

  if (!user || !userProfile) {
    throw new UserNotFoundError(userId);
  }

  if (user.loginName !== email && (await isUserExistsByLoginName(email))) {
    throw new DuplicatedUserError();
  }
  const transaction = await sequelize.transaction();

  let newHashPassword = undefined;
  if (newPassword) {
    newHashPassword = await hashPassword(newPassword);
  }

  try {
    await user.update({ loginName: email, password: newHashPassword }, { transaction });
    await userProfile.update({ email, displayName, contactNumber }, { transaction });

    if (roleId) {
      await UserProfileRoleDao.update(userId, roleId, transaction);
    }

    await transaction.commit();

    return await getUserFullDetailsById(user.id);
  } catch (err) {
    await transaction.rollback();
    throw err;
  }
};

/**
 * To activate (undelete) a user. Need to check for the licenses of Tenant
 *
 * @param userId of the user to be activated.
 *
 * @returns void
 */
export const activateUser = async (userId: number) => {
  const user = await UserDao.getById(userId);
  const tenantKey = user.get('TenantKey') as string;

  if (!(await TenantService.validateLicenseLimit(tenantKey))) {
    throw new ExceededLicenseUsageError();
  }

  await user.update({ active: true });
};

/**
 * To unlock a user (and reset failed login count)
 *
 * @param userId of the user to be unlocked.
 *
 * @returns void
 */
export const unlockUser = async (userId: number) => {
  const user = await UserDao.getById(userId);

  if (!user) {
    throw new UserNotFoundError(userId);
  }

  await user.update({ lock: false, invalidLogin: 0 });
};

/**
 * To deactivate (soft delete) a user
 *
 * @param userId of the user to be deactivated
 *
 * @returns void
 */
export const deactivateUser = async (userId: number) => {
  const user = await UserDao.getById(userId);

  if (!user) {
    throw new UserNotFoundError(userId);
  }

  await user.update({ active: false });
};

/**
 * Check if a user exists
 *
 * @param loginName of the required user
 *
 * @returns boolean
 */
export const isUserExistsByLoginName = async (loginName: string): Promise<boolean> => {
  return (await UserDao.countByLoginName(loginName)) > 0;
};

/**
 * get all active users
 */
export const getActiveUsers = async (): Promise<ActiveUserResponseModel[]> => {
  LOG.debug('Getting all active users ');

  const activeUsers = await UserProfileDao.getActiveUsers();

  return activeUsers;
};
